{# VHDL AXI-Lite Bus Wrapper Template #}
{# Generates AXI-Lite slave interface with register decoding #}
--------------------------------------------------------------------------------
-- Entity: {{ entity_name }}_axil
-- Description: AXI-Lite slave interface for register access
-- Generated by fpga_lib VHDL Generator
--
-- Register Map:
{% for reg in registers %}
--   {{ "0x%04X" | format(loop.index0 * reg_width) }} : {{ reg.name }} ({{ reg.access }})
{% endfor %}
--------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

use work.{{ entity_name }}_pkg.all;

entity {{ entity_name }}_axil is
  port (
    -- Clock and reset
    clk : in std_logic;
    rst : in std_logic;
    
    -- AXI-Lite Slave Interface
    s_axi_awaddr  : in  std_logic_vector(C_ADDR_WIDTH-1 downto 0);
    s_axi_awprot  : in  std_logic_vector(2 downto 0);
    s_axi_awvalid : in  std_logic;
    s_axi_awready : out std_logic;
    s_axi_wdata   : in  std_logic_vector(C_DATA_WIDTH-1 downto 0);
    s_axi_wstrb   : in  std_logic_vector((C_DATA_WIDTH/8)-1 downto 0);
    s_axi_wvalid  : in  std_logic;
    s_axi_wready  : out std_logic;
    s_axi_bresp   : out std_logic_vector(1 downto 0);
    s_axi_bvalid  : out std_logic;
    s_axi_bready  : in  std_logic;
    s_axi_araddr  : in  std_logic_vector(C_ADDR_WIDTH-1 downto 0);
    s_axi_arprot  : in  std_logic_vector(2 downto 0);
    s_axi_arvalid : in  std_logic;
    s_axi_arready : out std_logic;
    s_axi_rdata   : out std_logic_vector(C_DATA_WIDTH-1 downto 0);
    s_axi_rresp   : out std_logic_vector(1 downto 0);
    s_axi_rvalid  : out std_logic;
    s_axi_rready  : in  std_logic;
    
    -- Register interface
    regs_out : out t_regs_sw2hw;  -- To core (SW-writable)
    regs_in  : in  t_regs_hw2sw   -- From core (HW-writable)
  );
end entity {{ entity_name }}_axil;

architecture rtl of {{ entity_name }}_axil is

  -- AXI-Lite response constants
  constant C_RESP_OKAY   : std_logic_vector(1 downto 0) := "00";
  constant C_RESP_SLVERR : std_logic_vector(1 downto 0) := "10";

  -- State machine
  type t_axi_state is (IDLE, WRITE_DATA, WRITE_RESP, READ_DATA);
  signal state : t_axi_state := IDLE;
  
  -- Address latches
  signal awaddr_reg : unsigned(C_ADDR_WIDTH-1 downto 0);
  signal araddr_reg : unsigned(C_ADDR_WIDTH-1 downto 0);
  signal wstrb_reg  : std_logic_vector((C_DATA_WIDTH/8)-1 downto 0);
  
  -- Internal register storage
  signal regs : t_regs_sw2hw := C_REGS_SW2HW_RESET;

  -- Apply write strobe to data
  function apply_wstrb(
    old_data : std_logic_vector(C_DATA_WIDTH-1 downto 0);
    new_data : std_logic_vector(C_DATA_WIDTH-1 downto 0);
    wstrb    : std_logic_vector((C_DATA_WIDTH/8)-1 downto 0)
  ) return std_logic_vector is
    variable result : std_logic_vector(C_DATA_WIDTH-1 downto 0);
  begin
    for i in 0 to (C_DATA_WIDTH/8)-1 loop
      if wstrb(i) = '1' then
        result(i*8+7 downto i*8) := new_data(i*8+7 downto i*8);
      else
        result(i*8+7 downto i*8) := old_data(i*8+7 downto i*8);
      end if;
    end loop;
    return result;
  end function;

begin

  -- Output register values to core
  regs_out <= regs;

  ----------------------------------------------------------------------------
  -- AXI-Lite State Machine
  ----------------------------------------------------------------------------
  p_axi : process(clk)
    variable v_addr_index : natural;
    variable v_wdata      : std_logic_vector(C_DATA_WIDTH-1 downto 0);
  begin
    if rising_edge(clk) then
      if rst = '1' then
        state         <= IDLE;
        s_axi_awready <= '0';
        s_axi_wready  <= '0';
        s_axi_bvalid  <= '0';
        s_axi_arready <= '0';
        s_axi_rvalid  <= '0';
        s_axi_rdata   <= (others => '0');
        s_axi_bresp   <= C_RESP_OKAY;
        s_axi_rresp   <= C_RESP_OKAY;
        regs          <= C_REGS_SW2HW_RESET;
      else
        case state is
        
          when IDLE =>
            s_axi_bvalid <= '0';
            s_axi_rvalid <= '0';
            
            if s_axi_awvalid = '1' then
              -- Write address phase
              s_axi_awready <= '1';
              awaddr_reg    <= unsigned(s_axi_awaddr);
              state         <= WRITE_DATA;
            elsif s_axi_arvalid = '1' then
              -- Read address phase
              s_axi_arready <= '1';
              araddr_reg    <= unsigned(s_axi_araddr);
              state         <= READ_DATA;
            end if;
            
          when WRITE_DATA =>
            s_axi_awready <= '0';
            s_axi_wready  <= '1';
            
            if s_axi_wvalid = '1' then
              s_axi_wready <= '0';
              
              -- Decode address and write register
              v_addr_index := to_integer(awaddr_reg(C_ADDR_WIDTH-1 downto 2));
              
              case v_addr_index is
{% for reg in registers if reg.access in ['read-write', 'write-only', 'rw', 'wo'] %}
                when t_reg_id'pos(REG_{{ reg.name | upper }}) =>
                  -- Apply write strobe
                  v_wdata := apply_wstrb(to_slv(regs.{{ reg.name | lower }}), s_axi_wdata, s_axi_wstrb);
                  regs.{{ reg.name | lower }} <= to_{{ reg.name | lower }}(v_wdata);
{% endfor %}
                when others =>
                  null;  -- Ignore writes to unknown addresses
              end case;
              
              s_axi_bresp <= C_RESP_OKAY;
              state       <= WRITE_RESP;
            end if;
            
          when WRITE_RESP =>
            s_axi_bvalid <= '1';
            if s_axi_bready = '1' then
              s_axi_bvalid <= '0';
              state        <= IDLE;
            end if;
            
          when READ_DATA =>
            s_axi_arready <= '0';
            
            -- Decode address and read register
            v_addr_index := to_integer(araddr_reg(C_ADDR_WIDTH-1 downto 2));
            
            case v_addr_index is
{% for reg in registers %}
{% if reg.access in ['read-only', 'ro'] %}
              when t_reg_id'pos(REG_{{ reg.name | upper }}) =>
                s_axi_rdata <= to_slv(regs_in.{{ reg.name | lower }});
{% elif reg.access in ['read-write', 'rw'] %}
              when t_reg_id'pos(REG_{{ reg.name | upper }}) =>
                s_axi_rdata <= to_slv(regs.{{ reg.name | lower }});
{% endif %}
{% endfor %}
              when others =>
                s_axi_rdata <= (others => '0');
            end case;
            
            s_axi_rresp  <= C_RESP_OKAY;
            s_axi_rvalid <= '1';
            
            if s_axi_rready = '1' then
              s_axi_rvalid <= '0';
              state        <= IDLE;
            end if;
            
        end case;
      end if;
    end if;
  end process;

end architecture rtl;
