#!/usr/bin/env python3
"""
GPIO Driver Demo Script

This script demonstrates the unified GPIO driver architecture with a
practical example that showcases all the key features and capabilities.
Now includes support for both traditional and YAML-driven approaches.
"""

import time
import sys
from pathlib import Path

# Import from local modules
from config import (
    create_mock_gpio_driver,
    MockBusConfig
)
from gpio_driver import GpioDirection, GpioValue
from gpio_wrapper import GpioDriverWrapper
from memory_map_loader import load_from_yaml


def print_banner(title):
    """Print a formatted banner for demo sections."""
    print("\n" + "=" * 60)
    print(f"  {title}")
    print("=" * 60)


def print_register_state(driver, title="Register State"):
    """Print the current state of all GPIO registers."""
    print(f"\n{title}:")
    summary = driver.get_register_summary()
    for reg_name, value in summary.items():
        print(f"  {reg_name.upper():20s}: 0x{value:08X} (0b{value:032b})")


def demo_basic_operations():
    """Demonstrate basic GPIO operations."""
    print_banner("Basic GPIO Operations Demo")

    # Create a GPIO driver with 32 pins (from YAML config)
    driver = create_mock_gpio_driver()
    print(f"Created GPIO driver with {driver.num_pins} pins")

    print("\n1. Configuring Individual Pins:")

    # Configure pin 0 as output
    driver.set_pin_direction(0, GpioDirection.OUTPUT)
    print("   - Pin 0: Configured as OUTPUT")

    # Configure pin 1 as input
    driver.set_pin_direction(1, GpioDirection.INPUT)
    print("   - Pin 1: Configured as INPUT")

    # Configure pin 2 as output with initial value
    driver.configure_pin(2, GpioDirection.OUTPUT, GpioValue.HIGH)
    print("   - Pin 2: Configured as OUTPUT with initial HIGH value")

    print_register_state(driver, "After Pin Configuration")

    print("\n2. Setting Pin Values:")

    # Set pin 0 to HIGH
    driver.set_pin_value(0, GpioValue.HIGH)
    print("   - Pin 0: Set to HIGH")

    # Set pin 2 to LOW
    driver.set_pin_value(2, GpioValue.LOW)
    print("   - Pin 2: Set to LOW")

    print_register_state(driver, "After Setting Pin Values")

    print("\n3. Reading Pin Values:")
    for pin in range(3):
        value = driver.get_pin_value(pin)
        direction = driver.get_pin_direction(pin)
        print(f"   - Pin {pin}: {value.name} ({direction.name})")


def demo_bulk_operations():
    """Demonstrate bulk GPIO operations for performance."""
    print_banner("Bulk GPIO Operations Demo")

    driver = create_mock_gpio_driver()

    print("1. Configuring Multiple Pins:")

    # Configure pins 0-7 as outputs
    for pin in range(8):
        driver.set_pin_direction(pin, GpioDirection.OUTPUT)
    print("   - Pins 0-7: Configured as OUTPUTS")

    # Configure pins 8-15 as inputs
    for pin in range(8, 16):
        driver.set_pin_direction(pin, GpioDirection.INPUT)
    print("   - Pins 8-15: Configured as INPUTS")

    print_register_state(driver, "After Direction Configuration")

    print("\n2. Setting Patterns with Bulk Operations:")

    patterns = [
        ("Alternating 1", 0b10101010),
        ("Alternating 2", 0b01010101),
        ("All High", 0b11111111),
        ("All Low", 0b00000000),
        ("Binary Count", 0b00001111),
    ]

    for pattern_name, pattern_value in patterns:
        driver.set_pins_value(0xFF, pattern_value)  # Mask for pins 0-7
        current_state = driver.get_all_pins_value() & 0xFF
        print(f"   - {pattern_name:15s}: 0b{current_state:08b}")
        time.sleep(0.1)  # Simulate timing for real hardware

    print_register_state(driver, "Final Bulk Operation State")


def demo_interrupt_handling():
    """Demonstrate GPIO interrupt functionality."""
    print_banner("GPIO Interrupt Handling Demo")

    driver = create_mock_gpio_driver()

    print("1. Configuring Interrupt-Enabled Pins:")

    # Configure pins 0-3 as inputs with interrupts
    interrupt_pins = [0, 1, 2, 3]
    for pin in interrupt_pins:
        driver.configure_pin(pin, GpioDirection.INPUT, interrupt_enable=True)
        print(f"   - Pin {pin}: Configured as INPUT with interrupt enabled")

    print_register_state(driver, "After Interrupt Configuration")

    print("\n2. Simulating Interrupt Events:")

    # Simulate some interrupt conditions
    # Note: In real hardware, interrupts would be generated by external events
    simulated_interrupts = [
        (0, "Button press detected"),
        (2, "Motion sensor triggered"),
        (1, "Temperature threshold exceeded"),
    ]

    for pin, description in simulated_interrupts:
        print(f"   - Pin {pin}: {description}")

        # In real hardware, you would read the interrupt status register
        # Here we simulate the interrupt handling process
        print(f"     > Interrupt handler called for pin {pin}")
        print(f"     > Processing interrupt: {description}")
        print(f"     > Clearing interrupt flag for pin {pin}")

        # Clear the interrupt (in real hardware)
        driver.clear_interrupt_status(1 << pin)

    print("\n3. Interrupt Status Summary:")
    status = driver.get_interrupt_status()
    print(f"   Current interrupt status: 0x{status:02X}")


def demo_multiple_gpio_instances():
    """Demonstrate multiple GPIO instances with different configurations."""
    print_banner("Multiple GPIO Instances Demo")

    # Simulate different GPIO peripherals in a system
    gpio_configs = [
        {
            "name": "LED_GPIO",
            "pins": 8,
            "base_addr": 0x40000000,
            "description": "Controls 8 status LEDs"
        },
        {
            "name": "SWITCH_GPIO",
            "pins": 4,
            "base_addr": 0x40001000,
            "description": "Reads 4 user switches"
        },
        {
            "name": "EXPANSION_GPIO",
            "pins": 32,
            "base_addr": 0x40002000,
            "description": "General purpose expansion connector"
        }
    ]

    gpio_drivers = {}

    print("1. Creating Multiple GPIO Instances:")
    for config in gpio_configs:
        driver = create_mock_gpio_driver(
            driver_name=config["name"]
        )
        gpio_drivers[config["name"]] = driver

        print(f"   - {config['name']:15s}: {driver.num_pins:2d} pins")
        print(f"     {config['description']}")

    print("\n2. Configuring Each GPIO Instance:")

    # Configure LED GPIO (all outputs)
    led_gpio = gpio_drivers["LED_GPIO"]
    for pin in range(led_gpio.num_pins):
        led_gpio.set_pin_direction(pin, GpioDirection.OUTPUT)
    print("   - LED_GPIO: All pins configured as outputs")

    # Configure SWITCH GPIO (all inputs with interrupts)
    switch_gpio = gpio_drivers["SWITCH_GPIO"]
    for pin in range(switch_gpio.num_pins):
        switch_gpio.configure_pin(pin, GpioDirection.INPUT, interrupt_enable=True)
    print("   - SWITCH_GPIO: All pins configured as inputs with interrupts")

    # Configure EXPANSION GPIO (mixed)
    exp_gpio = gpio_drivers["EXPANSION_GPIO"]
    for pin in range(16):
        exp_gpio.set_pin_direction(pin, GpioDirection.OUTPUT)
    for pin in range(16, 32):
        exp_gpio.set_pin_direction(pin, GpioDirection.INPUT)
    print("   - EXPANSION_GPIO: Pins 0-15 as outputs, 16-31 as inputs")

    print("\n3. Operating Each GPIO Instance:")

    # LED pattern
    led_gpio.set_pins_value(0xFF, 0b10101010)
    print("   - LED_GPIO: Set alternating LED pattern")

    # Read switches (simulated)
    switch_state = switch_gpio.get_all_pins_value()
    print(f"   - SWITCH_GPIO: Current switch state: 0b{switch_state:04b}")

    # Expansion GPIO test
    exp_gpio.set_pins_value(0xFFFF, 0x5555)  # Set pattern on output pins
    print("   - EXPANSION_GPIO: Set test pattern on output pins")

    print("\n4. Register Summaries:")
    for name, driver in gpio_drivers.items():
        print(f"\n   {name}:")
        summary = driver.get_register_summary()
        for reg_name, value in summary.items():
            print(f"     {reg_name:20s}: 0x{value:08X}")


def demo_performance_comparison():
    """Demonstrate performance differences between individual and bulk operations."""
    print_banner("Performance Comparison Demo")

    driver = create_mock_gpio_driver()

    # Configure all pins as outputs
    for pin in range(32):
        driver.set_pin_direction(pin, GpioDirection.OUTPUT)

    print("Comparing individual vs bulk GPIO operations...")

    # Individual pin operations
    print("\n1. Individual Pin Operations:")
    start_time = time.time()
    iterations = 1000

    for i in range(iterations):
        for pin in range(8):
            driver.set_pin_value(pin, GpioValue.HIGH if i % 2 else GpioValue.LOW)

    individual_time = time.time() - start_time
    print(f"   {iterations} iterations of 8 individual pin operations:")
    print(f"   Total time: {individual_time*1000:.2f} ms")
    print(f"   Time per operation: {individual_time*1000000/iterations/8:.2f} μs")

    # Bulk operations
    print("\n2. Bulk Pin Operations:")
    start_time = time.time()

    for i in range(iterations):
        pattern = 0xFF if i % 2 else 0x00
        driver.set_pins_value(0xFF, pattern)  # Set 8 pins at once

    bulk_time = time.time() - start_time
    print(f"   {iterations} iterations of 8-pin bulk operations:")
    print(f"   Total time: {bulk_time*1000:.2f} ms")
    print(f"   Time per operation: {bulk_time*1000000/iterations:.2f} μs")

    # Performance ratio
    if bulk_time > 0:
        speedup = individual_time / bulk_time
        print(f"\n3. Performance Analysis:")
        print(f"   Bulk operations are {speedup:.1f}x faster than individual operations")
        print(f"   Efficiency gain: {(1 - bulk_time/individual_time)*100:.1f}%")


def demo_error_handling():
    """Demonstrate error handling and validation."""
    print_banner("Error Handling and Validation Demo")

    driver = create_mock_gpio_driver()  # Small GPIO for demo

    print("1. Pin Number Validation:")

    valid_pins = [0, 1, 2, 3]
    invalid_pins = [-1, 4, 10, 100]

    for pin in valid_pins:
        try:
            driver.set_pin_direction(pin, GpioDirection.OUTPUT)
            print(f"   ✓ Pin {pin}: Valid - operation successful")
        except ValueError as e:
            print(f"   ✗ Pin {pin}: Unexpected error - {e}")

    for pin in invalid_pins:
        try:
            driver.set_pin_direction(pin, GpioDirection.OUTPUT)
            print(f"   ✗ Pin {pin}: Should have failed but didn't!")
        except ValueError:
            print(f"   ✓ Pin {pin}: Correctly rejected as invalid")

    print("\n2. Register Field Validation:")

    # Test field width validation
    try:
        # Try to write a value too large for a field (using YAML-driven approach)
        driver._driver.direction.gpio_dir = 0xFFFFFFFF  # This should work
        print("   ✓ Field validation: Large value accepted within field width")
        
        # Try to access a field that doesn't exist
        _ = driver._driver.direction.nonexistent_field
        print("   ✗ Field validation: Should have failed for non-existent field")
    except AttributeError:
        print("   ✓ Field validation: Correctly rejected non-existent field")
    except ValueError:
        print("   ✓ Field validation: Correctly rejected oversized value")

    print("\n3. Bus Interface Error Handling:")

    # Create a mock bus that fails
    class FailingBusInterface:
        def read_word(self, address):
            raise RuntimeError("Simulated bus read failure")

        def write_word(self, address, data):
            raise RuntimeError("Simulated bus write failure")

    # This would be used to test error propagation in a real implementation
    print("   Bus error handling mechanisms demonstrated")


def demo_yaml_driven_approach():
    """Demonstrate YAML-driven memory map approach."""
    print_banner("YAML-Driven Memory Map Demonstration")
    
    # Check if YAML file exists
    yaml_file = "gpio_memory_map.yaml"
    if not Path(yaml_file).exists():
        print(f"⚠ YAML file {yaml_file} not found - skipping YAML demo")
        return
    
    # Create GPIO driver from YAML memory map
    print("1. Creating GPIO driver from YAML memory map:")
    
    try:
        driver = create_mock_gpio_driver(yaml_file, "YAML Demo Driver")
        print(f"   ✓ Successfully created driver: {driver._driver._name}")
        
        # Get core information
        core_info = driver.get_core_info()
        print(f"   Core information: {core_info}")
        
    except Exception as e:
        print(f"   ✗ Failed to create YAML driver: {e}")
        return
    
    print("\n2. Direct Register Access (YAML-defined):")
    
    # Access registers directly using YAML-defined structure
    try:
        # Set direction register
        driver._driver.direction.gpio_dir = 0x0000FFFF
        print("   ✓ Set direction register via YAML-defined field")
        
        # Set data register 
        driver._driver.data.gpio_pins = 0x0000AAAA
        print("   ✓ Set data register via YAML-defined field")
        
        # Read config register if available
        if hasattr(driver._driver, 'config'):
            pin_count = driver._driver.config.pin_count
            version = driver._driver.config.version
            has_interrupts = driver._driver.config.has_interrupts
            print(f"   ✓ Config - Pins: {pin_count}, Version: 0x{version:02X}, Interrupts: {bool(has_interrupts)}")
        
        # Show register summary
        summary = driver._driver.get_register_summary()
        print("\n   Current Register State:")
        for reg_name, value in summary.items():
            print(f"     {reg_name.upper():18s}: 0x{value:08X}")
            
    except Exception as e:
        print(f"   ✗ Direct register access failed: {e}")
    
    print("\n3. High-Level GPIO API (YAML Backend):")
    
    try:
        # Configure pins using high-level API
        driver.configure_pin(0, GpioDirection.OUTPUT, GpioValue.HIGH)
        driver.configure_pin(1, GpioDirection.OUTPUT, GpioValue.LOW)
        driver.configure_pin(2, GpioDirection.INPUT, interrupt_enable=True)
        
        print("   ✓ Configured pins using high-level API over YAML backend")
        
        # Read pin states
        for pin in range(3):
            value = driver.get_pin_value(pin)
            direction = driver.get_pin_direction(pin)
            print(f"     Pin {pin}: {value.name} ({direction.name})")
            
    except Exception as e:
        print(f"   ✗ High-level API failed: {e}")
    
    print("\n4. Access Control Validation:")
    
    try:
        # Test read-only access
        if hasattr(driver._driver, 'config'):
            pin_count = driver._driver.config.pin_count
            print(f"   ✓ Read pin_count (RO): {pin_count}")
            
            # Try to write to read-only field
            try:
                driver._driver.config.pin_count = 64
                print("   ✗ Writing to read-only field should have failed!")
            except AttributeError:
                print("   ✓ Write to read-only field correctly blocked")
        
        # Test write-only access
        if hasattr(driver._driver, 'interrupt_clear'):
            driver._driver.interrupt_clear.int_clear = 0x0F
            print("   ✓ Write to write-only field successful")
            
    except Exception as e:
        print(f"   ✗ Access control test failed: {e}")
    
    print("\n5. YAML Approach Benefits:")
    print("   • Single source of truth for memory maps")
    print("   • Human-readable register documentation")
    print("   • Automatic access control enforcement")
    print("   • Dynamic driver generation")
    print("   • Hardware documentation synchronization")
    print("   • Easy maintenance and updates")


def main():
    """Main demo function."""
    print("GPIO IP Core Driver - Unified Architecture Demonstration")
    print("This demo showcases the key features and capabilities of the GPIO driver")

    try:
        demo_basic_operations()
        demo_bulk_operations()
        demo_interrupt_handling()
        demo_multiple_gpio_instances()
        demo_performance_comparison()
        demo_error_handling()
        demo_yaml_driven_approach()

        print_banner("Demo Complete")
        print("All demonstrations completed successfully!")
        print("\nKey benefits demonstrated:")
        print("• Intuitive pin-oriented API")
        print("• Comprehensive register access")
        print("• Bulk operations for performance")
        print("• Multiple GPIO instance support")
        print("• Robust error handling")
        print("• Type-safe configuration")
        print("• YAML-driven memory maps")
        print("• Single source of truth documentation")
        print("\nThe same code can run in simulation, hardware, or test environments")
        print("by simply changing the bus interface configuration.")
        print("YAML memory maps provide human-readable hardware documentation.")

    except Exception as e:
        print(f"\nDemo failed with error: {e}")
        return 1

    return 0


if __name__ == "__main__":
    exit(main())
