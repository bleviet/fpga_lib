#!/usr/bin/env python3
"""
GPIO Driver Demo Script

This script demonstrates the unified GPIO driver architecture with a
practical example that showcases all the key features and capabilities.
"""

import time
import sys
from pathlib import Path

# Import from local modules
from config import (
    create_mock_gpio_driver,
    GpioDriverConfig,
    MockBusConfig,
    create_gpio_driver
)
from gpio_driver import GpioDirection, GpioValue


def print_banner(title):
    """Print a formatted banner for demo sections."""
    print("\n" + "=" * 60)
    print(f"  {title}")
    print("=" * 60)


def print_register_state(driver, title="Register State"):
    """Print the current state of all GPIO registers."""
    print(f"\n{title}:")
    summary = driver.get_register_summary()
    for reg_name, value in summary.items():
        print(f"  {reg_name.upper():20s}: 0x{value:08X} (0b{value:032b})")


def demo_basic_operations():
    """Demonstrate basic GPIO operations."""
    print_banner("Basic GPIO Operations Demo")

    # Create a GPIO driver with 8 pins
    driver = create_mock_gpio_driver(num_pins=8)
    print(f"Created GPIO driver with {driver.num_pins} pins")

    print("\n1. Configuring Individual Pins:")

    # Configure pin 0 as output
    driver.set_pin_direction(0, GpioDirection.OUTPUT)
    print("   - Pin 0: Configured as OUTPUT")

    # Configure pin 1 as input
    driver.set_pin_direction(1, GpioDirection.INPUT)
    print("   - Pin 1: Configured as INPUT")

    # Configure pin 2 as output with initial value
    driver.configure_pin(2, GpioDirection.OUTPUT, GpioValue.HIGH)
    print("   - Pin 2: Configured as OUTPUT with initial HIGH value")

    print_register_state(driver, "After Pin Configuration")

    print("\n2. Setting Pin Values:")

    # Set pin 0 to HIGH
    driver.set_pin_value(0, GpioValue.HIGH)
    print("   - Pin 0: Set to HIGH")

    # Set pin 2 to LOW
    driver.set_pin_value(2, GpioValue.LOW)
    print("   - Pin 2: Set to LOW")

    print_register_state(driver, "After Setting Pin Values")

    print("\n3. Reading Pin Values:")
    for pin in range(3):
        value = driver.get_pin_value(pin)
        direction = driver.get_pin_direction(pin)
        print(f"   - Pin {pin}: {value.name} ({direction.name})")


def demo_bulk_operations():
    """Demonstrate bulk GPIO operations for performance."""
    print_banner("Bulk GPIO Operations Demo")

    driver = create_mock_gpio_driver(num_pins=16)

    print("1. Configuring Multiple Pins:")

    # Configure pins 0-7 as outputs
    for pin in range(8):
        driver.set_pin_direction(pin, GpioDirection.OUTPUT)
    print("   - Pins 0-7: Configured as OUTPUTS")

    # Configure pins 8-15 as inputs
    for pin in range(8, 16):
        driver.set_pin_direction(pin, GpioDirection.INPUT)
    print("   - Pins 8-15: Configured as INPUTS")

    print_register_state(driver, "After Direction Configuration")

    print("\n2. Setting Patterns with Bulk Operations:")

    patterns = [
        ("Alternating 1", 0b10101010),
        ("Alternating 2", 0b01010101),
        ("All High", 0b11111111),
        ("All Low", 0b00000000),
        ("Binary Count", 0b00001111),
    ]

    for pattern_name, pattern_value in patterns:
        driver.set_pins_value(0xFF, pattern_value)  # Mask for pins 0-7
        current_state = driver.get_all_pins_value() & 0xFF
        print(f"   - {pattern_name:15s}: 0b{current_state:08b}")
        time.sleep(0.1)  # Simulate timing for real hardware

    print_register_state(driver, "Final Bulk Operation State")


def demo_interrupt_handling():
    """Demonstrate GPIO interrupt functionality."""
    print_banner("GPIO Interrupt Handling Demo")

    driver = create_mock_gpio_driver(num_pins=8)

    print("1. Configuring Interrupt-Enabled Pins:")

    # Configure pins 0-3 as inputs with interrupts
    interrupt_pins = [0, 1, 2, 3]
    for pin in interrupt_pins:
        driver.configure_pin(pin, GpioDirection.INPUT, interrupt_enable=True)
        print(f"   - Pin {pin}: Configured as INPUT with interrupt enabled")

    print_register_state(driver, "After Interrupt Configuration")

    print("\n2. Simulating Interrupt Events:")

    # Simulate some interrupt conditions
    # Note: In real hardware, interrupts would be generated by external events
    simulated_interrupts = [
        (0, "Button press detected"),
        (2, "Motion sensor triggered"),
        (1, "Temperature threshold exceeded"),
    ]

    for pin, description in simulated_interrupts:
        print(f"   - Pin {pin}: {description}")

        # In real hardware, you would read the interrupt status register
        # Here we simulate the interrupt handling process
        print(f"     > Interrupt handler called for pin {pin}")
        print(f"     > Processing interrupt: {description}")
        print(f"     > Clearing interrupt flag for pin {pin}")

        # Clear the interrupt (in real hardware)
        driver.clear_interrupt_status(1 << pin)

    print("\n3. Interrupt Status Summary:")
    status = driver.get_interrupt_status()
    print(f"   Current interrupt status: 0x{status:02X}")


def demo_multiple_gpio_instances():
    """Demonstrate multiple GPIO instances with different configurations."""
    print_banner("Multiple GPIO Instances Demo")

    # Simulate different GPIO peripherals in a system
    gpio_configs = [
        {
            "name": "LED_GPIO",
            "pins": 8,
            "base_addr": 0x40000000,
            "description": "Controls 8 status LEDs"
        },
        {
            "name": "SWITCH_GPIO",
            "pins": 4,
            "base_addr": 0x40001000,
            "description": "Reads 4 user switches"
        },
        {
            "name": "EXPANSION_GPIO",
            "pins": 32,
            "base_addr": 0x40002000,
            "description": "General purpose expansion connector"
        }
    ]

    gpio_drivers = {}

    print("1. Creating Multiple GPIO Instances:")
    for config in gpio_configs:
        driver = create_mock_gpio_driver(
            num_pins=config["pins"],
            base_address=config["base_addr"]
        )
        gpio_drivers[config["name"]] = driver

        print(f"   - {config['name']:15s}: {config['pins']:2d} pins at 0x{config['base_addr']:08X}")
        print(f"     {config['description']}")

    print("\n2. Configuring Each GPIO Instance:")

    # Configure LED GPIO (all outputs)
    led_gpio = gpio_drivers["LED_GPIO"]
    for pin in range(led_gpio.num_pins):
        led_gpio.set_pin_direction(pin, GpioDirection.OUTPUT)
    print("   - LED_GPIO: All pins configured as outputs")

    # Configure SWITCH GPIO (all inputs with interrupts)
    switch_gpio = gpio_drivers["SWITCH_GPIO"]
    for pin in range(switch_gpio.num_pins):
        switch_gpio.configure_pin(pin, GpioDirection.INPUT, interrupt_enable=True)
    print("   - SWITCH_GPIO: All pins configured as inputs with interrupts")

    # Configure EXPANSION GPIO (mixed)
    exp_gpio = gpio_drivers["EXPANSION_GPIO"]
    for pin in range(16):
        exp_gpio.set_pin_direction(pin, GpioDirection.OUTPUT)
    for pin in range(16, 32):
        exp_gpio.set_pin_direction(pin, GpioDirection.INPUT)
    print("   - EXPANSION_GPIO: Pins 0-15 as outputs, 16-31 as inputs")

    print("\n3. Operating Each GPIO Instance:")

    # LED pattern
    led_gpio.set_pins_value(0xFF, 0b10101010)
    print("   - LED_GPIO: Set alternating LED pattern")

    # Read switches (simulated)
    switch_state = switch_gpio.get_all_pins_value()
    print(f"   - SWITCH_GPIO: Current switch state: 0b{switch_state:04b}")

    # Expansion GPIO test
    exp_gpio.set_pins_value(0xFFFF, 0x5555)  # Set pattern on output pins
    print("   - EXPANSION_GPIO: Set test pattern on output pins")

    print("\n4. Register Summaries:")
    for name, driver in gpio_drivers.items():
        print(f"\n   {name}:")
        summary = driver.get_register_summary()
        for reg_name, value in summary.items():
            print(f"     {reg_name:20s}: 0x{value:08X}")


def demo_performance_comparison():
    """Demonstrate performance differences between individual and bulk operations."""
    print_banner("Performance Comparison Demo")

    driver = create_mock_gpio_driver(num_pins=32)

    # Configure all pins as outputs
    for pin in range(32):
        driver.set_pin_direction(pin, GpioDirection.OUTPUT)

    print("Comparing individual vs bulk GPIO operations...")

    # Individual pin operations
    print("\n1. Individual Pin Operations:")
    start_time = time.time()
    iterations = 1000

    for i in range(iterations):
        for pin in range(8):
            driver.set_pin_value(pin, GpioValue.HIGH if i % 2 else GpioValue.LOW)

    individual_time = time.time() - start_time
    print(f"   {iterations} iterations of 8 individual pin operations:")
    print(f"   Total time: {individual_time*1000:.2f} ms")
    print(f"   Time per operation: {individual_time*1000000/iterations/8:.2f} μs")

    # Bulk operations
    print("\n2. Bulk Pin Operations:")
    start_time = time.time()

    for i in range(iterations):
        pattern = 0xFF if i % 2 else 0x00
        driver.set_pins_value(0xFF, pattern)  # Set 8 pins at once

    bulk_time = time.time() - start_time
    print(f"   {iterations} iterations of 8-pin bulk operations:")
    print(f"   Total time: {bulk_time*1000:.2f} ms")
    print(f"   Time per operation: {bulk_time*1000000/iterations:.2f} μs")

    # Performance ratio
    if bulk_time > 0:
        speedup = individual_time / bulk_time
        print(f"\n3. Performance Analysis:")
        print(f"   Bulk operations are {speedup:.1f}x faster than individual operations")
        print(f"   Efficiency gain: {(1 - bulk_time/individual_time)*100:.1f}%")


def demo_error_handling():
    """Demonstrate error handling and validation."""
    print_banner("Error Handling and Validation Demo")

    driver = create_mock_gpio_driver(num_pins=4)  # Small GPIO for demo

    print("1. Pin Number Validation:")

    valid_pins = [0, 1, 2, 3]
    invalid_pins = [-1, 4, 10, 100]

    for pin in valid_pins:
        try:
            driver.set_pin_direction(pin, GpioDirection.OUTPUT)
            print(f"   ✓ Pin {pin}: Valid - operation successful")
        except ValueError as e:
            print(f"   ✗ Pin {pin}: Unexpected error - {e}")

    for pin in invalid_pins:
        try:
            driver.set_pin_direction(pin, GpioDirection.OUTPUT)
            print(f"   ✗ Pin {pin}: Should have failed but didn't!")
        except ValueError:
            print(f"   ✓ Pin {pin}: Correctly rejected as invalid")

    print("\n2. Register Field Validation:")

    # Test field width validation
    try:
        # Try to write a value too large for a single pin (enable field is 1 bit)
        driver.direction_reg.write_field("gpio_dir", 0x1F)  # 5 bits for 4-pin GPIO
        print("   ✗ Field validation: Should have failed for oversized value")
    except ValueError:
        print("   ✓ Field validation: Correctly rejected oversized value")

    print("\n3. Bus Interface Error Handling:")

    # Create a mock bus that fails
    class FailingBusInterface:
        def read_word(self, address):
            raise RuntimeError("Simulated bus read failure")

        def write_word(self, address, data):
            raise RuntimeError("Simulated bus write failure")

    # This would be used to test error propagation in a real implementation
    print("   Bus error handling mechanisms demonstrated")


def main():
    """Main demo function."""
    print("GPIO IP Core Driver - Unified Architecture Demonstration")
    print("This demo showcases the key features and capabilities of the GPIO driver")

    try:
        demo_basic_operations()
        demo_bulk_operations()
        demo_interrupt_handling()
        demo_multiple_gpio_instances()
        demo_performance_comparison()
        demo_error_handling()

        print_banner("Demo Complete")
        print("All demonstrations completed successfully!")
        print("\nKey benefits demonstrated:")
        print("• Intuitive pin-oriented API")
        print("• Comprehensive register access")
        print("• Bulk operations for performance")
        print("• Multiple GPIO instance support")
        print("• Robust error handling")
        print("• Type-safe configuration")
        print("\nThe same code can run in simulation, hardware, or test environments")
        print("by simply changing the bus interface configuration.")

    except Exception as e:
        print(f"\nDemo failed with error: {e}")
        return 1

    return 0


if __name__ == "__main__":
    exit(main())
