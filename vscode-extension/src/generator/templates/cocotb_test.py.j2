# {{ entity_name }}_test.py - cocotb Testbench
# Generated by fpga_lib VHDL Generator
#
# Provides automated register read/write testing via AXI-Lite interface.
# Run with: make SIM=ghdl TOPLEVEL={{ entity_name }} MODULE={{ entity_name }}_test

import cocotb
from cocotb.clock import Clock
from cocotb.triggers import RisingEdge, Timer, ClockCycles
from cocotb.regression import TestFactory
import random
import os

# Check for cocotbext-axi
try:
    from cocotbext.axi import AxiLiteMaster, AxiLiteBus
except ImportError:
    raise ImportError("Testbench requires cocotbext-axi. Install with: pip install cocotbext-axi")


async def reset_dut(dut):
    """Assert reset for specified cycles."""
    dut.rst.value = 1
    await ClockCycles(dut.clk, 10)
    dut.rst.value = 0
    await ClockCycles(dut.clk, 2)


# =============================================================================
# Register Addresses
# =============================================================================
{% for reg in registers %}
REG_{{ reg.name | upper }}_ADDR = {{ "0x%04X" | format(loop.index0 * reg_width) }}
{% endfor %}


# =============================================================================
# Test: Reset Values
# =============================================================================
@cocotb.test()
async def test_reset_values(dut):
    """Verify all registers read their reset values after reset."""
    # Start clock
    clock = Clock(dut.clk, 10, units="ns")
    cocotb.start_soon(clock.start())
    
    # Initialize AXI Master
    # Assumes s_axi_ naming convention from top wrapper
    bus = AxiLiteBus.from_prefix(dut, "s_axi")
    axi = AxiLiteMaster(bus, dut.clk, dut.rst)

    # Perform Reset
    await reset_dut(dut)
    
    dut._log.info("Testing register reset values...")
    
{% for reg in registers if reg.access in ['read-write', 'read-only', 'rw', 'ro'] %}
    # {{ reg.name }}: expected reset = {{ reg.fields[0].reset_value if reg.fields else 0 }}
    res = await axi.read(REG_{{ reg.name | upper }}_ADDR, 4)
    val = int.from_bytes(res.data, byteorder='little')
    dut._log.info(f"{{ reg.name }}: read 0x{val:08X}")
{% endfor %}
    
    dut._log.info("Reset value test complete!")


# =============================================================================
# Test: Read/Write RW Registers
# =============================================================================
@cocotb.test()
async def test_rw_registers(dut):
    """Test read/write access to all RW registers."""
    # Start clock
    clock = Clock(dut.clk, 10, units="ns")
    cocotb.start_soon(clock.start())
    
    # Initialize AXI Master
    bus = AxiLiteBus.from_prefix(dut, "s_axi")
    axi = AxiLiteMaster(bus, dut.clk, dut.rst)

    # Perform Reset
    await reset_dut(dut)
    
    dut._log.info("Testing read/write registers...")
    
{% for reg in registers if reg.access in ['read-write', 'rw'] %}
    # Test {{ reg.name }}
    test_val = 0xDEADBEEF & {{ "0x%08X" | format((2 ** 32) - 1) }}
    await axi.write(REG_{{ reg.name | upper }}_ADDR, test_val.to_bytes(4, byteorder='little'))
    
    res = await axi.read(REG_{{ reg.name | upper }}_ADDR, 4)
    read_val = int.from_bytes(res.data, byteorder='little')
    
    dut._log.info(f"{{ reg.name }}: wrote 0x{test_val:08X}, read 0x{read_val:08X}")
    # Note: May not match exactly due to field widths and reserved bits
    
{% endfor %}
    dut._log.info("Read/write test complete!")


# =============================================================================
# Test: Random Access
# =============================================================================
@cocotb.test()
async def test_random_access(dut):
    """Perform random read/write access to registers."""
    # Start clock
    clock = Clock(dut.clk, 10, units="ns")
    cocotb.start_soon(clock.start())
    
    # Initialize AXI Master
    bus = AxiLiteBus.from_prefix(dut, "s_axi")
    axi = AxiLiteMaster(bus, dut.clk, dut.rst)

    # Perform Reset
    await reset_dut(dut)
    
    dut._log.info("Testing random access pattern...")
    
    rw_regs = [
{% for reg in registers if reg.access in ['read-write', 'rw'] %}
        REG_{{ reg.name | upper }}_ADDR,
{% endfor %}
    ]
    
    if not rw_regs:
        dut._log.info("No RW registers to test.")
        return

    # Store written values
    written = {}
    
    # Random writes
    for _ in range(20):
        addr = random.choice(rw_regs)
        data = random.randint(0, 0xFFFFFFFF)
        await axi.write(addr, data.to_bytes(4, byteorder='little'))
        written[addr] = data
        
    # Verify last written values
    for addr, expected in written.items():
        res = await axi.read(addr, 4)
        actual = int.from_bytes(res.data, byteorder='little')
        dut._log.info(f"Addr 0x{addr:04X}: expected 0x{expected:08X}, got 0x{actual:08X}")
        
    dut._log.info("Random access test complete!")


# =============================================================================
# Test: Write Strobe
# =============================================================================
@cocotb.test()
async def test_write_strobe(dut):
    """Test partial writes using write strobe."""
    # Start clock
    clock = Clock(dut.clk, 10, units="ns")
    cocotb.start_soon(clock.start())
    
    # Initialize AXI Master
    bus = AxiLiteBus.from_prefix(dut, "s_axi")
    axi = AxiLiteMaster(bus, dut.clk, dut.rst)

    # Perform Reset
    await reset_dut(dut)
    
    dut._log.info("Testing write strobe...")
    
{% if registers | selectattr('access', 'in', ['read-write', 'rw']) | list %}
    # Use first RW register for strobe test
    test_addr = REG_{{ (registers | selectattr('access', 'in', ['read-write', 'rw']) | first).name | upper }}_ADDR
    
    # Write all 1s
    await axi.write(test_addr, (0xFFFFFFFF).to_bytes(4, byteorder='little'))
    
    # Partial write: only byte 0 (strb=0x1) -> cocotbext-axi handles strb automatically based on byte enables? 
    # Use explicit strobe
    await axi.write(test_addr, (0x00).to_bytes(1, byteorder='little') + (0x00).to_bytes(3, byteorder='little'), awprot=0, wstrb=0x1)
    
    # Note: cocotbext-axi write signature is write(address, data, awid=None, awuser=None, awprot=None, wstrb=None, wuser=None)
    # But usually it infers strobe from data length? 
    # Actually, for 32-bit width, passing 4 bytes is standard.
    # explicit wstrb override:
    await axi.write(test_addr, (0x00000000).to_bytes(4, byteorder='little'), wstrb=0x1)
    
    res = await axi.read(test_addr, 4)
    val = int.from_bytes(res.data, byteorder='little')
    dut._log.info(f"After byte0 clear: 0x{val:08X} (expected 0xFFFFFF00)")
    
    # Partial write: only byte 2 (strb=0x4)
    await axi.write(test_addr, (0xFFFFFFFF).to_bytes(4, byteorder='little'))
    await axi.write(test_addr, (0x00000000).to_bytes(4, byteorder='little'), wstrb=0x4)
    
    res = await axi.read(test_addr, 4)
    val = int.from_bytes(res.data, byteorder='little')
    dut._log.info(f"After byte2 clear: 0x{val:08X} (expected 0xFF00FFFF)")
{% endif %}
    
    dut._log.info("Write strobe test complete!")
