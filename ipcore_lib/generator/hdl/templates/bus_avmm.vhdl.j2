{# VHDL Avalon-MM Bus Wrapper Template #}
{# Generates Avalon-MM slave interface with register decoding #}
--------------------------------------------------------------------------------
-- Entity: {{ entity_name }}_avmm
-- Description: Avalon-MM slave interface for register access
-- Generated by ipcore_lib VHDL Generator
--
-- Register Map:
{%- for reg in registers %}
--   {{ "0x%04X" | format(loop.index0 * reg_width) }} : {{ reg.name }} ({{ reg.access }})
{%- endfor %}
--------------------------------------------------------------------------------

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

use work.{{ entity_name }}_pkg.all;

entity {{ entity_name }}_avmm is
  port (
    -- Clock and reset
    clk : in std_logic;
    rst : in std_logic;
    
    -- Avalon-MM Slave Interface
    avs_address       : in  std_logic_vector(C_ADDR_WIDTH-1 downto 0);
    avs_read          : in  std_logic;
    avs_readdata      : out std_logic_vector(C_DATA_WIDTH-1 downto 0);
    avs_readdatavalid : out std_logic;
    avs_write         : in  std_logic;
    avs_writedata     : in  std_logic_vector(C_DATA_WIDTH-1 downto 0);
    avs_byteenable    : in  std_logic_vector((C_DATA_WIDTH/8)-1 downto 0);
    avs_waitrequest   : out std_logic;
    
    -- Register interface
    regs_out : out t_regs_sw2hw;  -- To core (SW-writable)
    regs_in  : in  t_regs_hw2sw   -- From core (HW-writable)
  );
end entity {{ entity_name }}_avmm;

architecture rtl of {{ entity_name }}_avmm is

  -- Internal register storage
  signal regs : t_regs_sw2hw := C_REGS_SW2HW_RESET;
  
  -- Read pipeline
  signal rd_valid : std_logic := '0';
  signal rd_data  : std_logic_vector(C_DATA_WIDTH-1 downto 0) := (others => '0');

  -- Apply byte enable to data
  function apply_byteenable(
    old_data   : std_logic_vector(C_DATA_WIDTH-1 downto 0);
    new_data   : std_logic_vector(C_DATA_WIDTH-1 downto 0);
    byteenable : std_logic_vector((C_DATA_WIDTH/8)-1 downto 0)
  ) return std_logic_vector is
    variable result : std_logic_vector(C_DATA_WIDTH-1 downto 0);
  begin
    for i in 0 to (C_DATA_WIDTH/8)-1 loop
      if byteenable(i) = '1' then
        result(i*8+7 downto i*8) := new_data(i*8+7 downto i*8);
      else
        result(i*8+7 downto i*8) := old_data(i*8+7 downto i*8);
      end if;
    end loop;
    return result;
  end function;

begin

  -- Output register values to core
  regs_out <= regs;
  
  -- No wait states
  avs_waitrequest   <= '0';
  avs_readdata      <= rd_data;
  avs_readdatavalid <= rd_valid;

  ----------------------------------------------------------------------------
  -- Write Process
  ----------------------------------------------------------------------------
  p_write : process(clk)
    variable v_addr_index : natural;
    variable v_wdata      : std_logic_vector(C_DATA_WIDTH-1 downto 0);
  begin
    if rising_edge(clk) then
      if rst = '1' then
        regs <= C_REGS_SW2HW_RESET;
      elsif avs_write = '1' then
        v_addr_index := to_integer(unsigned(avs_address(C_ADDR_WIDTH-1 downto 2)));
        
        case v_addr_index is
{%- for reg in registers if reg.access in ['read-write', 'write-only', 'rw', 'wo'] %}
          when t_reg_id'pos(REG_{{ reg.name | upper }}) =>
            v_wdata := apply_byteenable(to_slv(regs.{{ reg.name | lower }}), avs_writedata, avs_byteenable);
            regs.{{ reg.name | lower }} <= to_{{ reg.name | lower }}(v_wdata);
{%- endfor %}
          when others =>
            null;
        end case;
      end if;
    end if;
  end process;

  ----------------------------------------------------------------------------
  -- Read Process
  ----------------------------------------------------------------------------
  p_read : process(clk)
    variable v_addr_index : natural;
  begin
    if rising_edge(clk) then
      rd_valid <= '0';
      
      if rst = '1' then
        rd_data  <= (others => '0');
        rd_valid <= '0';
      elsif avs_read = '1' then
        v_addr_index := to_integer(unsigned(avs_address(C_ADDR_WIDTH-1 downto 2)));
        
        case v_addr_index is
{%- for reg in registers %}
{%- if reg.access in ['read-only', 'ro'] %}
          when t_reg_id'pos(REG_{{ reg.name | upper }}) =>
            rd_data <= to_slv(regs_in.{{ reg.name | lower }});
{%- elif reg.access in ['read-write', 'rw'] %}
          when t_reg_id'pos(REG_{{ reg.name | upper }}) =>
            rd_data <= to_slv(regs.{{ reg.name | lower }});
{%- endif %}
{%- endfor %}
          when others =>
            rd_data <= (others => '0');
        end case;
        
        rd_valid <= '1';
      end if;
    end if;
  end process;

end architecture rtl;
